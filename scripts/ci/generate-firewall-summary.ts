#!/usr/bin/env node
/**
 * Generate GitHub Actions step summary from Squid firewall logs
 *
 * This script parses Squid proxy logs generated by awf and creates a markdown summary
 * showing firewall activity (allowed/blocked requests by domain).
 *
 * Usage:
 *   npx tsx scripts/ci/generate-firewall-summary.ts <logs-directory>
 *
 * The script reads access.log from the specified directory and writes a summary
 * to GITHUB_STEP_SUMMARY if available, or stdout otherwise.
 */

import * as fs from 'fs';
import * as path from 'path';

/**
 * Parsed log entry from Squid's firewall_detailed log format
 */
interface ParsedLogEntry {
  timestamp: number;
  clientIp: string;
  clientPort: string;
  host: string;
  destIp: string;
  destPort: string;
  protocol: string;
  method: string;
  statusCode: number;
  decision: string;
  url: string;
  userAgent: string;
  domain: string;
  isAllowed: boolean;
  isHttps: boolean;
}

/**
 * Regex pattern for parsing Squid's firewall_detailed log format
 *
 * Log format: %ts.%03tu %>a:%>p %{Host}>h %<a:%<p %rv %rm %>Hs %Ss:%Sh %ru "%{User-Agent}>h"
 *
 * Example:
 * 1761074374.646 172.30.0.20:39748 api.github.com:443 140.82.114.22:443 1.1 CONNECT 200 TCP_TUNNEL:HIER_DIRECT api.github.com:443 "-"
 */
const LOG_PATTERN =
  /^(\d+\.\d+)\s+([^:]+):(\d+)\s+(\S+)\s+([^:]+):(\S+)\s+(\S+)\s+(\S+)\s+(\d+)\s+(\S+)\s+(\S+)\s+"([^"]*)"/;

/**
 * Extracts the domain name from log fields
 *
 * For CONNECT requests, the domain is in the URL field (e.g., "api.github.com:443")
 * For other methods, the domain is in the Host header
 *
 * @param url - URL field from the log
 * @param host - Host header field from the log
 * @param method - HTTP method
 * @returns Extracted domain name without port
 */
function extractDomain(url: string, host: string, method: string): string {
  if (method === 'CONNECT') {
    // For CONNECT, URL is domain:port
    const colonIndex = url.lastIndexOf(':');
    if (colonIndex !== -1) {
      const possiblePort = url.substring(colonIndex + 1);
      // Only strip if it looks like a port number
      if (/^\d+$/.test(possiblePort)) {
        return url.substring(0, colonIndex);
      }
    }
    return url;
  }

  // For other methods, use Host header
  if (host && host !== '-') {
    const colonIndex = host.lastIndexOf(':');
    if (colonIndex !== -1) {
      const possiblePort = host.substring(colonIndex + 1);
      if (/^\d+$/.test(possiblePort)) {
        return host.substring(0, colonIndex);
      }
    }
    return host;
  }

  // Fallback: try to parse domain from URL
  try {
    // Handle URLs that might not have a protocol
    const urlWithProtocol = url.startsWith('http') ? url : `http://${url}`;
    const urlObj = new URL(urlWithProtocol);
    return urlObj.hostname;
  } catch {
    return url;
  }
}

/**
 * Parses a single Squid log line into a structured entry
 *
 * @param line - Raw log line from access.log
 * @returns Parsed log entry or null if parsing failed
 */
function parseLogLine(line: string): ParsedLogEntry | null {
  const trimmed = line.trim();
  if (!trimmed) {
    return null;
  }

  const match = trimmed.match(LOG_PATTERN);
  if (!match) {
    return null;
  }

  const [
    ,
    timestampStr,
    clientIp,
    clientPort,
    host,
    destIp,
    destPort,
    protocol,
    method,
    statusCodeStr,
    decision,
    url,
    userAgent,
  ] = match;

  const timestamp = parseFloat(timestampStr);
  const statusCode = parseInt(statusCodeStr, 10);
  const isAllowed =
    decision.startsWith('TCP_TUNNEL') || decision.startsWith('TCP_MISS');
  const isHttps = method === 'CONNECT';

  // Extract domain from the appropriate field
  const domain = extractDomain(url, host, method);

  return {
    timestamp,
    clientIp,
    clientPort,
    host,
    destIp,
    destPort,
    protocol,
    method,
    statusCode,
    decision,
    url,
    userAgent,
    domain,
    isAllowed,
    isHttps,
  };
}

/**
 * Analysis result for firewall logs
 */
interface FirewallAnalysis {
  totalRequests: number;
  allowedRequests: number;
  deniedRequests: number;
  allowedDomains: string[];
  deniedDomains: string[];
  requestsByDomain: Map<string, { allowed: number; denied: number }>;
}

/**
 * Analyzes parsed log entries to produce summary statistics
 */
function analyzeEntries(entries: ParsedLogEntry[]): FirewallAnalysis {
  const requestsByDomain = new Map<string, { allowed: number; denied: number }>();
  const allowedDomainsSet = new Set<string>();
  const deniedDomainsSet = new Set<string>();
  let allowedRequests = 0;
  let deniedRequests = 0;

  for (const entry of entries) {
    // Skip entries with no domain (shouldn't happen, but just in case)
    if (!entry.domain || entry.domain === '-') {
      continue;
    }

    // Get or create domain stats
    if (!requestsByDomain.has(entry.domain)) {
      requestsByDomain.set(entry.domain, { allowed: 0, denied: 0 });
    }
    const stats = requestsByDomain.get(entry.domain)!;

    if (entry.isAllowed) {
      stats.allowed++;
      allowedRequests++;
      allowedDomainsSet.add(entry.domain);
    } else {
      stats.denied++;
      deniedRequests++;
      deniedDomainsSet.add(entry.domain);
    }
  }

  return {
    totalRequests: entries.length,
    allowedRequests,
    deniedRequests,
    allowedDomains: Array.from(allowedDomainsSet).sort(),
    deniedDomains: Array.from(deniedDomainsSet).sort(),
    requestsByDomain,
  };
}

/**
 * Generates a markdown summary for GitHub Actions step summary
 */
function generateSummary(analysis: FirewallAnalysis): string {
  const {
    totalRequests,
    allowedRequests,
    deniedRequests,
    requestsByDomain,
  } = analysis;

  // Filter out invalid domains
  const validDomains = Array.from(requestsByDomain.keys())
    .filter(domain => domain !== '-' && domain !== '')
    .sort();

  const uniqueDomainCount = validDomains.length;

  let summary = '### ðŸ”¥ Firewall Activity\n\n';
  summary += '<details>\n';
  summary += `<summary>ðŸ“Š ${totalRequests} request${totalRequests !== 1 ? 's' : ''} | `;
  summary += `${allowedRequests} allowed | `;
  summary += `${deniedRequests} blocked | `;
  summary += `${uniqueDomainCount} unique domain${uniqueDomainCount !== 1 ? 's' : ''}</summary>\n\n`;

  if (uniqueDomainCount > 0) {
    summary += '| Domain | Allowed | Denied |\n';
    summary += '|--------|---------|--------|\n';

    for (const domain of validDomains) {
      const stats = requestsByDomain.get(domain)!;
      summary += `| ${domain} | ${stats.allowed} | ${stats.denied} |\n`;
    }
  } else {
    summary += 'No firewall activity detected.\n';
  }

  summary += '\n</details>\n\n';
  return summary;
}

/**
 * Main function
 */
function main(): void {
  const args = process.argv.slice(2);

  if (args.length < 1) {
    console.error('Usage: generate-firewall-summary.ts <logs-directory>');
    console.error('');
    console.error('Example:');
    console.error('  npx tsx scripts/ci/generate-firewall-summary.ts /tmp/gh-aw/sandbox/firewall/logs/');
    process.exit(1);
  }

  const logsDir = args[0];

  // Check if directory exists
  if (!fs.existsSync(logsDir)) {
    console.log(`No firewall logs directory found at: ${logsDir}`);
    return;
  }

  // Find log files in the directory
  const files = fs.readdirSync(logsDir).filter(file => file.endsWith('.log'));

  if (files.length === 0) {
    console.log(`No firewall log files found in: ${logsDir}`);
    return;
  }

  console.log(`Found ${files.length} firewall log file(s)`);

  // Parse all log files
  const entries: ParsedLogEntry[] = [];

  for (const file of files) {
    const filePath = path.join(logsDir, file);
    console.log(`Parsing firewall log: ${file}`);

    const content = fs.readFileSync(filePath, 'utf8');
    const lines = content.split('\n').filter(line => line.trim());

    for (const line of lines) {
      const entry = parseLogLine(line);
      if (entry) {
        entries.push(entry);
      }
    }
  }

  // Analyze entries
  const analysis = analyzeEntries(entries);

  // Generate summary
  const summary = generateSummary(analysis);

  // Write to GITHUB_STEP_SUMMARY or stdout
  const summaryPath = process.env.GITHUB_STEP_SUMMARY;
  if (summaryPath) {
    fs.appendFileSync(summaryPath, summary);
    console.log('Firewall log summary generated successfully');
  } else {
    console.log('');
    console.log('--- Summary ---');
    console.log(summary);
  }
}

main();
