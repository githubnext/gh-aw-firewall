#!/bin/bash
set -e

echo "[entrypoint] Agentic Workflow Firewall - Agent Container"
echo "[entrypoint] =================================="

# Adjust awfuser UID/GID to match host user at runtime
# This ensures file ownership is correct regardless of whether using GHCR images or local builds
HOST_UID=${AWF_USER_UID:-$(id -u awfuser)}
HOST_GID=${AWF_USER_GID:-$(id -g awfuser)}
CURRENT_UID=$(id -u awfuser)
CURRENT_GID=$(id -g awfuser)

# Validate UID/GID values to prevent security issues
if ! [[ "$HOST_UID" =~ ^[0-9]+$ ]]; then
  echo "[entrypoint][ERROR] Invalid AWF_USER_UID: must be numeric"
  exit 1
fi

if ! [[ "$HOST_GID" =~ ^[0-9]+$ ]]; then
  echo "[entrypoint][ERROR] Invalid AWF_USER_GID: must be numeric"
  exit 1
fi

# Prevent setting UID/GID to 0 (root) which defeats the privilege drop
if [ "$HOST_UID" -eq 0 ]; then
  echo "[entrypoint][ERROR] Invalid AWF_USER_UID: cannot be 0 (root)"
  exit 1
fi

if [ "$HOST_GID" -eq 0 ]; then
  echo "[entrypoint][ERROR] Invalid AWF_USER_GID: cannot be 0 (root)"
  exit 1
fi

if [ "$CURRENT_UID" != "$HOST_UID" ] || [ "$CURRENT_GID" != "$HOST_GID" ]; then
  echo "[entrypoint] Adjusting awfuser UID:GID from $CURRENT_UID:$CURRENT_GID to $HOST_UID:$HOST_GID"
  
  # Check if target GID is already in use by another group
  EXISTING_GROUP=$(getent group "$HOST_GID" 2>/dev/null | cut -d: -f1 || true)
  if [ -n "$EXISTING_GROUP" ] && [ "$EXISTING_GROUP" != "awfuser" ]; then
    echo "[entrypoint][WARN] Target GID $HOST_GID is already used by group '$EXISTING_GROUP'. Skipping GID change."
  else
    # Change GID first (must be done before UID change)
    if ! groupmod -g "$HOST_GID" awfuser 2>/dev/null; then
      echo "[entrypoint][ERROR] Failed to change GID of awfuser to $HOST_GID"
      exit 1
    fi
  fi
  
  # Check if target UID is already in use by another user
  EXISTING_USER=$(getent passwd "$HOST_UID" 2>/dev/null | cut -d: -f1 || true)
  if [ -n "$EXISTING_USER" ] && [ "$EXISTING_USER" != "awfuser" ]; then
    echo "[entrypoint][WARN] Target UID $HOST_UID is already used by user '$EXISTING_USER'. Skipping UID change."
  else
    # Change UID
    if ! usermod -u "$HOST_UID" awfuser 2>/dev/null; then
      echo "[entrypoint][ERROR] Failed to change UID of awfuser to $HOST_UID"
      exit 1
    fi
  fi
  
  # Fix ownership of awfuser's home directory
  chown -R awfuser:awfuser /home/awfuser 2>/dev/null || true
  echo "[entrypoint] UID/GID adjustment complete"
fi

# Fix DNS configuration - ensure external DNS works alongside Docker's embedded DNS
# Docker's embedded DNS (127.0.0.11) is used for service name resolution (e.g., squid-proxy)
# Trusted external DNS servers are used for internet domain resolution
echo "[entrypoint] Configuring DNS..."

# Check if DNS-over-HTTPS is enabled
if [ "${AWF_DOH_ENABLED}" = "true" ]; then
  echo "[entrypoint] DNS-over-HTTPS mode enabled"
  DOH_RESOLVER="${AWF_DOH_RESOLVER:-https://dns.google/dns-query}"
  echo "[entrypoint] Starting cloudflared DoH proxy with resolver: $DOH_RESOLVER"

  # Start cloudflared as a local DNS proxy that forwards to DoH resolver
  # Runs in background, listening on 127.0.0.53:53 for DNS queries
  cloudflared proxy-dns \
    --address 127.0.0.53 \
    --port 53 \
    --upstream "$DOH_RESOLVER" \
    2>&1 | sed 's/^/[cloudflared] /' &

  CLOUDFLARED_PID=$!
  echo "[entrypoint] cloudflared started with PID: $CLOUDFLARED_PID"

  # Wait for cloudflared to be ready (with timeout)
  MAX_WAIT=10
  WAITED=0
  while ! nc -z 127.0.0.53 53 2>/dev/null; do
    if [ $WAITED -ge $MAX_WAIT ]; then
      echo "[entrypoint][ERROR] cloudflared failed to start within ${MAX_WAIT}s"
      exit 1
    fi
    sleep 0.5
    WAITED=$((WAITED + 1))
  done
  echo "[entrypoint] cloudflared is ready and listening on 127.0.0.53:53"

  # Configure resolv.conf to use cloudflared as primary DNS
  if [ -f /etc/resolv.conf ]; then
    cp /etc/resolv.conf /etc/resolv.conf.orig
    {
      echo "# Generated by awf entrypoint - DNS-over-HTTPS mode"
      echo "# Docker embedded DNS for service name resolution (squid-proxy, etc.)"
      echo "nameserver 127.0.0.11"
      echo "# cloudflared DoH proxy for encrypted internet DNS"
      echo "nameserver 127.0.0.53"
      echo "options ndots:0"
    } > /etc/resolv.conf
    echo "[entrypoint] DNS configured with cloudflared DoH proxy"
  fi
else
  # Traditional DNS mode
  if [ -f /etc/resolv.conf ]; then
    # Backup original resolv.conf
    cp /etc/resolv.conf /etc/resolv.conf.orig

    # Get DNS servers from environment (default to Google DNS)
    DNS_SERVERS="${AWF_DNS_SERVERS:-8.8.8.8,8.8.4.4}"

    # Create new resolv.conf with Docker embedded DNS first, then trusted external DNS servers
    {
      echo "# Generated by awf entrypoint"
      echo "# Docker embedded DNS for service name resolution (squid-proxy, etc.)"
      echo "nameserver 127.0.0.11"
      echo "# Trusted external DNS servers for internet domain resolution"

      # Add each trusted DNS server
      IFS=',' read -ra DNS_ARRAY <<< "$DNS_SERVERS"
      for dns_server in "${DNS_ARRAY[@]}"; do
        dns_server=$(echo "$dns_server" | tr -d ' ')
        if [ -n "$dns_server" ]; then
          echo "nameserver $dns_server"
        fi
      done

      echo "options ndots:0"
    } > /etc/resolv.conf

    echo "[entrypoint] DNS configured with Docker embedded DNS (127.0.0.11) and trusted servers: $DNS_SERVERS"
  fi
fi

# Update CA certificates if SSL Bump is enabled
# The CA certificate is mounted at /usr/local/share/ca-certificates/awf-ca.crt
if [ "${AWF_SSL_BUMP_ENABLED}" = "true" ]; then
  echo "[entrypoint] SSL Bump mode detected - updating CA certificates..."
  if [ -f /usr/local/share/ca-certificates/awf-ca.crt ]; then
    update-ca-certificates 2>/dev/null
    echo "[entrypoint] CA certificates updated for SSL Bump"
    echo "[entrypoint] ⚠️  WARNING: HTTPS traffic will be intercepted for URL inspection"
  else
    echo "[entrypoint][WARN] SSL Bump enabled but CA certificate not found"
  fi
fi

# Setup iptables rules
/usr/local/bin/setup-iptables.sh

# Print proxy environment
echo "[entrypoint] Proxy configuration:"
echo "[entrypoint]   HTTP_PROXY=$HTTP_PROXY"
echo "[entrypoint]   HTTPS_PROXY=$HTTPS_PROXY"

# Print network information
echo "[entrypoint] Network information:"
echo "[entrypoint]   IP address: $(hostname -I)"
echo "[entrypoint]   Hostname: $(hostname)"

# Configure git safe directories for awfuser
# Use runuser instead of su to avoid PAM session issues
runuser -u awfuser -- git config --global --add safe.directory '*' 2>/dev/null || true

echo "[entrypoint] =================================="
echo "[entrypoint] Dropping CAP_NET_ADMIN capability and privileges to awfuser (UID: $(id -u awfuser), GID: $(id -g awfuser))"
echo "[entrypoint] Executing command: $@"
echo ""

# Drop CAP_NET_ADMIN capability and privileges, then execute the user command
# This prevents malicious code from modifying iptables rules to bypass the firewall
# Security note: capsh --drop removes the capability from the bounding set,
# preventing any process (even if it escalates to root) from acquiring it
# The order of operations:
# 1. capsh drops CAP_NET_ADMIN from the bounding set (cannot be regained)
# 2. gosu switches to awfuser (drops root privileges)
# 3. exec replaces the current process with the user command
exec capsh --drop=cap_net_admin -- -c "exec gosu awfuser $(printf '%q ' "$@")"
